#!/usr/bin/env node

import fs from 'node:fs';
import path from 'node:path';

const repoRoot = path.resolve(path.dirname(new URL(import.meta.url).pathname), '..');
const researchPath = path.join(repoRoot, 'src', 'data', 'researchAlternatives.ts');
const manualPath = path.join(repoRoot, 'src', 'data', 'manualAlternatives.ts');
const outPath = path.join(repoRoot, 'src', 'data', 'trustWebSignals.ts');

const signalRules = {
  privacy: [
    /\bprivacy\b/,
    /\bdata protection\b/,
    /\bgdpr\b/,
    /\brgpd\b/,
    /\bnfadp\b/,
  ],
  openSourceMention: [
    /\bopen[ -]?source\b/,
    /\bgithub\b/,
    /\bsource code\b/,
  ],
  encryption: [
    /\bencryption\b/,
    /\bencrypted\b/,
    /\bzero[ -]?knowledge\b/,
    /\bend[ -]?to[ -]?end\b/,
    /\be2ee\b/,
  ],
  selfHosting: [
    /\bself[ -]?host\b/,
    /\bon[ -]?prem\b/,
    /\bfederated\b/,
  ],
  audit: [
    /\baudit\b/,
    /\bsoc ?2\b/,
    /\biso ?27001\b/,
    /\bindependent security\b/,
    /\bpenetration test\b/,
  ],
  noLogs: [
    /\bno[- ]?logs?\b/,
    /\blogless\b/,
  ],
};

function parseResearchAlternatives() {
  const source = fs.readFileSync(researchPath, 'utf8');
  const start = source.indexOf('=');
  const end = source.lastIndexOf(';');
  if (start === -1 || end === -1) {
    throw new Error('Cannot parse research alternatives.');
  }

  return JSON.parse(source.slice(start + 1, end).trim());
}

function parseManualAlternatives() {
  const source = fs.readFileSync(manualPath, 'utf8');
  const entries = [];
  const regex = /id:\s*'([^']+)'[\s\S]*?website:\s*'([^']+)'/g;

  for (const match of source.matchAll(regex)) {
    entries.push({
      id: match[1],
      website: match[2],
    });
  }

  return entries;
}

function normalizeWebsite(url) {
  if (/^https?:\/\//i.test(url)) return url;
  return `https://${url}`;
}

function stripHtml(html) {
  return html
    .replace(/<script\b[^>]*>[\s\S]*?<\/script>/gi, ' ')
    .replace(/<style\b[^>]*>[\s\S]*?<\/style>/gi, ' ')
    .replace(/<!--[\s\S]*?-->/g, ' ')
    .replace(/<[^>]+>/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

async function fetchWithTimeout(url, timeoutMs) {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeoutMs);

  try {
    return await fetch(url, {
      method: 'GET',
      redirect: 'follow',
      signal: controller.signal,
      headers: {
        'user-agent': 'european-alternatives-trust-bot/1.0 (+https://european-alternatives.cloud)',
        accept: 'text/html,application/xhtml+xml;q=0.9,*/*;q=0.8',
      },
    });
  } finally {
    clearTimeout(timer);
  }
}

function evaluateSignals(text) {
  const signals = {};
  for (const [key, patterns] of Object.entries(signalRules)) {
    signals[key] = patterns.some((pattern) => pattern.test(text));
  }
  const signalCount = Object.values(signals).filter(Boolean).length;
  return { signals, signalCount };
}

async function analyzeEntry(entry) {
  const normalized = normalizeWebsite(entry.website);
  const checkedAt = new Date().toISOString();

  try {
    const response = await fetchWithTimeout(normalized, 15000);
    const statusCode = response.status;
    const sourceUrl = normalized;

    if (!response.ok) {
      return {
        sourceUrl,
        checkedAt,
        statusCode,
        fetchError: `HTTP ${statusCode}`,
        signalCount: 0,
        signals: {
          privacy: false,
          openSourceMention: false,
          encryption: false,
          selfHosting: false,
          audit: false,
          noLogs: false,
        },
      };
    }

    const html = await response.text();
    const text = stripHtml(html).toLowerCase();
    const { signals, signalCount } = evaluateSignals(text);

    return {
      sourceUrl,
      checkedAt,
      statusCode,
      signalCount,
      signals,
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return {
      sourceUrl: normalized,
      checkedAt,
      fetchError: message,
      signalCount: 0,
      signals: {
        privacy: false,
        openSourceMention: false,
        encryption: false,
        selfHosting: false,
        audit: false,
        noLogs: false,
      },
    };
  }
}

function emitTypeScript(data) {
  const header = `// Generated by scripts/generate-trust-web-signals.mjs\n` +
    `// Derived from live vendor websites.\n\n`;

  const body = `export interface WebTrustSignals {\n` +
    `  sourceUrl: string;\n` +
    `  checkedAt: string;\n` +
    `  statusCode?: number;\n` +
    `  fetchError?: string;\n` +
    `  signalCount: number;\n` +
    `  signals: {\n` +
    `    privacy: boolean;\n` +
    `    openSourceMention: boolean;\n` +
    `    encryption: boolean;\n` +
    `    selfHosting: boolean;\n` +
    `    audit: boolean;\n` +
    `    noLogs: boolean;\n` +
    `  };\n` +
    `}\n\n` +
    `export const trustWebSignalsById: Record<string, WebTrustSignals> = ${JSON.stringify(data, null, 2)};\n`;

  fs.writeFileSync(outPath, header + body, 'utf8');
}

async function main() {
  const research = parseResearchAlternatives().map((entry) => ({
    id: entry.id,
    website: entry.website,
  }));
  const manual = parseManualAlternatives();

  const deduped = new Map();
  for (const entry of [...research, ...manual]) {
    if (!deduped.has(entry.id)) {
      deduped.set(entry.id, entry);
    }
  }

  const entries = Array.from(deduped.values()).sort((a, b) => a.id.localeCompare(b.id));
  const output = {};

  for (let i = 0; i < entries.length; i += 1) {
    const entry = entries[i];
    // Keep crawl polite and deterministic.
    process.stdout.write(`[${String(i + 1).padStart(2, '0')}/${entries.length}] ${entry.id}\n`);
    output[entry.id] = await analyzeEntry(entry);
    await new Promise((resolve) => setTimeout(resolve, 120));
  }

  emitTypeScript(output);
  process.stdout.write(`Wrote ${entries.length} trust web signal entries to ${path.relative(repoRoot, outPath)}\n`);
}

main().catch((error) => {
  process.stderr.write(`${error.stack || error}\n`);
  process.exit(1);
});
